# MySQL锁机制

## 前言

本文主要探究MySQL的锁机制。MySQL通过锁机制来解决并发控制读写的问题，锁保证数据并发访问的一致性、有效性。加锁会增加服务器开销，如获取锁、检测锁是否释放、释放锁等。由于MySQL InnoDB引擎使用广泛，MyISAM使用很少，本文主要介绍InnoDB引擎的锁机制。



## 读写锁

- 读锁（read lock），也叫共享锁（shared lock）：读锁是共享的，多个用户可以同时读取同一个资源，而互不干扰。

- 写锁（write lock），也叫排他锁（exclusive lock）：写锁是排他的，当一个用户持有了写锁，其他用户不能读取和写该资源，会造成阻塞。



## 粒度锁

为提高共享资源的并发性，可以使锁定的对象更加有选择性，那么需要尽量只对需要修改的部分进行加锁。锁定的资源越少，并发的程度就越高，但是随之而来的就是增大的锁开销，所谓的锁策略，就是在并发性和锁开销间取得一个好的平衡。大多数情况下，商业级数据库都是在表上施加行级锁来尽可能提供更好性能。

MySQL不同存储引擎支持不同的锁策略和锁粒度，所有的存储引擎都以自己的方式显现了锁机制，服务器层完全不了解存储引擎中的锁实现：

- MyISAM 和 MEMORY 存储引擎采用的是表级锁（table-level locking）
- BDB 存储引擎采用的是页面锁（page-level locking），但也支持表级锁
- InnoDB 存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁。

不同粒度锁的比较

| 粒度锁 | 优点                                 | 缺点                                         | 适合场景                                                     |
| ------ | ------------------------------------ | -------------------------------------------- | ------------------------------------------------------------ |
| 表级锁 | 开销小，加锁快，不会出现死锁         | 锁定粒度大，发生锁冲突的概率最高，并发度最低 | 以查询为主，并发用户少，只有少量按索引条件更新数据的应用     |
| 行级锁 | 锁定粒度小，锁冲突概率低，并发度最高 | 开销大，加锁慢，会出现死锁                   | 行级锁更适合于有大量按索引条件并发更新少量不同数据，<br>同时又有并发查询的应用，如一些在线事务处理（OLTP）系统 |
| 页面锁 | 介于表锁和行锁之间                   | 介于表锁和行锁之间                           | 略                                                           |



## InnoDB引擎锁机制

### **InnoDB行级锁**

- 共享锁（S）：允许一个事务去读一行，阻止其他事务获取相同数据集的排他锁。
- 排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。

### InnoDB表级锁

为允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁，这两种意向锁都是表锁：

- 意向共享锁（intention shared lock, IS）：事务打算给数据行加共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。

```sql
-- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。
SELECT column FROM table ... LOCK IN SHARE MODE;
```

- 意向排他锁（intention exclusive lock, IX）：事务发酸给数据行加排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。

```sql
-- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。
SELECT column FROM table ... FOR UPDATE;
```

#### 意向锁的兼容性

意向锁与意向锁之间是互相兼容的：

|              | 意向共享锁IS | 意向排他锁IX |
| ------------ | ------------ | ------------ |
| 意向共享锁IS | 兼容         | 兼容         |
| 意向排他锁IX | 兼容         | 兼容         |

虽然意向锁之间互相兼容，但是会与普通的共享/排他锁互斥：

|         | 意向共享锁IS | 意向排他锁IX |
| ------- | ------------ | ------------ |
| 共享锁S | 兼容         | 互斥         |
| 排他锁X | 互斥         | 互斥         |

注意这里的共享锁和排他锁指的是表锁，意向锁不会与行级的共享锁排他锁互斥。

#### 意向锁存在的意义

看到这可能还不是很清楚意向锁存在的意义是啥？举个例：

1.事务A获取了user表id=1的行的X，事务A会先获取user表的IX，再获取该行的X

2.事务B想要select...for update获取user表的X，此时会先查看user表此时的IX被事务A持有，由于事务B的X与IX互斥，所以获取失败，需要阻塞

3.如果没有意向锁会怎样？那么事务B就需要查看user表每一行是否存在S和X，确认没有之后才能获得user表的X。

#### 意向锁总结

1.InnoDB 支持多粒度锁，特定场景下，行级锁可以与表级锁共存。

2.意向锁之间互不排斥，但除了 IS 与 S 兼容外，意向锁会与 共享锁 / 排他锁 互斥。

3.IX，IS是表级锁，不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突。

4.意向锁在保证并发性的前提下，实现了行锁和表锁共存`且`满足事务隔离性的要求。



### InnoDB加锁方法

- 意向锁是 InnoDB 自动加的， 不需用户干预。

- 对于 UPDATE、 DELETE 和 INSERT 语句， InnoDB会自动给涉及数据集加排他锁（X)；

- 对于普通 SELECT 语句，InnoDB 不会加任何锁；事务可以通过以下语句显式给记录集加共享锁或排他锁：

- - 共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE。 其他 session 仍然可以查询记录，并也可以对该记录加 share mode 的共享锁。但是如果当前事务需要对该记录进行更新操作，则很有可能造成死锁。
  - 排他锁（X)：SELECT * FROM table_name WHERE ... FOR UPDATE。其他 session 可以查询该记录，但是不能对该记录加共享锁或排他锁，而是等待获得锁

- **隐式锁定：**

InnoDB在事务执行过程中，使用两阶段锁协议：

随时都可以执行锁定，InnoDB会根据隔离级别在需要的时候自动加锁；

锁只有在执行commit或者rollback的时候才会释放，并且所有的锁都是在**同一时刻**被释放。

- **显式锁定 ：**

```sql
select ... lock in share mode //共享锁 
select ... for update //排他锁 
```



### 行锁实现方式

- InnoDB 行锁是通过给索引上的索引项加锁来实现的，这一点 MySQL 与 Oracle 不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB 这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁。
- 不论是使用主键索引、唯一索引或普通索引，InnoDB 都会使用行锁来对数据加锁。
- 只有执行计划真正使用了索引，才能使用行锁：即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的，如果 MySQL 认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁，而不是行锁。因此，在分析锁冲突时，别忘了检查 SQL 的执行计划（可以通过 explain 检查 SQL 的执行计划），以确认是否真正使用了索引。
- 由于 MySQL 的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然多个session是访问不同行的记录， 但是如果是使用相同的索引键， 是会出现锁冲突的（后使用这些索引的session需要等待先使用索引的session释放锁后，才能获取锁）。 应用设计的时候要注意这一点。



### 间隙锁(Gap Lock)和Next-Key Lock

- 什么是间隙锁

  当我们在查询语句时，条件为范围查询时，InnoDB不管这个区间是否有数据，都会将其锁住，向这个区间的“间隙”（不存在的行）插入或删除数据都会阻塞。比如有 id 为：1、3、5、7 的 4 条数据，我们查找 1-7 范围的数据。那么 1-7 都会被加上锁。2、4、6 也在 1-7 的范围中，但是不存在这些数据记录，这些 2、4、6 就被称为间隙。

- 什么是Next-Key Lock

  **Next-Key Lock = Record Lock + Gap Lock**， InnoDB在默认隔离级别（Repeated Read）下，使用Next-Key Lock的方案解决了幻读的问题。

  - 幻读：在一次的事务操作中，先读取了几行数据后，另一个事务又增加或删除了数据，在此之后，此事务又去读取数据，发现数据凭空生成或消失，跟幻觉一样，即幻读。

  即在进行范围性的SELECT时，我们先对已经存在的Records加上`Record Lock`，再对此区间的间隙加上`Gap Lock`，从而解决了幻读的问题。

- 间隙锁的危害

  范围查找时，会把整个范围的数据全部锁定住，即便这个范围内不存在的一些数据，也会被无辜的锁定住，比如我要在 1、3、5、7 中插入 2，这个时候 1-7 都被锁定住了，根本无法插入 2。在某些场景下会对性能产生很大的影响

- 演示

新建表test_innodb_lock,数据如下所示，其中age字段已添加索引：

![image](https://user-images.githubusercontent.com/15052000/122141507-0fbb4900-ce80-11eb-97f7-03b36328091e.png)
使用update语句更新name，条件为age范围10-20，执行后，事务未提交：

![image-20210615165601459](MySQL锁机制.assets/image-20210615165601459.png)

打开另一个窗口，执行插入，其中age为17，在10-20范围内，如果上面的事务未提交，执行此语句会一直阻塞等待，直到超时：

![image-20210615165620718](MySQL锁机制.assets/image-20210615165620718.png)

![image-20210615170034006](MySQL锁机制.assets/image-20210615170034006.png)

